{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Summary \u00b6 ZonePlus is a module enabling the construction of dynamic zones. These zones utilise the new Spacial Query API and BasePart.CanTouch property to effectively determine players and parts within their boundaries. Creating a zone is as simple as: -- Assuming we place ZonePlus in ReplicatedStorage local Zone = require ( game : GetService ( \"ReplicatedStorage\" ). Zone ) local container = workspace . SafeZoneContainer local zone = Zone . new ( container ) Zones take one argument: a container . A container can be any non-basepart instance (such as a Model, Folder, etc) that contain descendant baseparts . Alternatively a container can be a singular basepart instance, or a table containing an array of baseparts. Info Zones are compatible with all basepart classes however it's recommended to use solely Blocks (i.e. Parts with Shape 'Block') when possible as these are better optimised (since only WorldRoot:GetPartBoundsInBox needs to be called instead of WorldRoot:GetPartsInPart ). These group parts are then used to define the region and precise bounds of the zone. Info Zones are dynamic. This means if a group part changes size or position, or if a basepart is added to or removed from the zone group, then an internal _update() method will be called to recalculate its bounds. Once constructed, you can utilise zone events to determine players, parts and the localplayer entering or exiting a zone. For instance, to listen for a player entering and exiting a zone, do: zone . playerEntered : Connect ( function ( player ) print (( \"%s entered the zone!\" ): format ( player . Name )) end ) zone . playerExited : Connect ( function ( player ) print (( \"%s exited the zone!\" ): format ( player . Name )) end ) Info On the client you may only wish to listen for the LocalPlayer (such as for an ambient system). To achieve this you would alternatively use the .localPlayer events. Important Initially zone parts should be located within Workspace to function properly. If you wish to move zones outside of Workspace (e.g. to prevent them interacting with other parts), consider using zone:relocate() . Important Zone parts must belong to the 'Default' (0) collision group. If you don't intend to frequently check for items entering and exiting a zone, you can utilise zone methods: local playersArray = zone : getPlayers () Discover the full set of methods, events and properties at the Zone API . Optimisations \u00b6 Zones by default perform up to 10 checks per second in the centre of characters. This behaviour can be changed by modifying the Accuracy and Detection of zones: Accuracy \u00b6 This determines the frequency of checks per second. The accuracy of a zone can be changed two ways with a corresponding Accuracy Enum : Using the zone:setAccuracy(itemName) method: zone : setAccuracy ( \"High\" ) Setting the zone.accuracy property: zone . accuracy = Zone . enum . Accuracy . High By default accuracy is High . Info Modifying the accuracy of one zone may impact the accuracy of another due to the modules collaborative nature. Detection \u00b6 This determines the precision of checks. The way a zone detects players and parts can be changed two ways with a corresponding Detection Enum : Using the zone:setDetection(itemName) method: zone : setDetection ( \"WholeBody\" ) Setting the zone.enterDetection and zone.exitDetection properties: zone . enterDetection = Zone . enum . Detection . WholeBody zone . exitDetection = Zone . enum . Detection . WholeBody By default enterDetection and exitDetection are Centre . Info Modifying the detection of one zone may impact the detection of another due to the modules collaborative nature. Warning Setting enterDetection to ( Zone.enum.Detection.WholeBody or Zone.enum.Detection.Automatic ) and exitDetection to Zone.enum.Detection.Centre may cause the entered and exit events to trigger rapidly when the player lies on the bounds of the zone.","title":"Introduction"},{"location":"#summary","text":"ZonePlus is a module enabling the construction of dynamic zones. These zones utilise the new Spacial Query API and BasePart.CanTouch property to effectively determine players and parts within their boundaries. Creating a zone is as simple as: -- Assuming we place ZonePlus in ReplicatedStorage local Zone = require ( game : GetService ( \"ReplicatedStorage\" ). Zone ) local container = workspace . SafeZoneContainer local zone = Zone . new ( container ) Zones take one argument: a container . A container can be any non-basepart instance (such as a Model, Folder, etc) that contain descendant baseparts . Alternatively a container can be a singular basepart instance, or a table containing an array of baseparts. Info Zones are compatible with all basepart classes however it's recommended to use solely Blocks (i.e. Parts with Shape 'Block') when possible as these are better optimised (since only WorldRoot:GetPartBoundsInBox needs to be called instead of WorldRoot:GetPartsInPart ). These group parts are then used to define the region and precise bounds of the zone. Info Zones are dynamic. This means if a group part changes size or position, or if a basepart is added to or removed from the zone group, then an internal _update() method will be called to recalculate its bounds. Once constructed, you can utilise zone events to determine players, parts and the localplayer entering or exiting a zone. For instance, to listen for a player entering and exiting a zone, do: zone . playerEntered : Connect ( function ( player ) print (( \"%s entered the zone!\" ): format ( player . Name )) end ) zone . playerExited : Connect ( function ( player ) print (( \"%s exited the zone!\" ): format ( player . Name )) end ) Info On the client you may only wish to listen for the LocalPlayer (such as for an ambient system). To achieve this you would alternatively use the .localPlayer events. Important Initially zone parts should be located within Workspace to function properly. If you wish to move zones outside of Workspace (e.g. to prevent them interacting with other parts), consider using zone:relocate() . Important Zone parts must belong to the 'Default' (0) collision group. If you don't intend to frequently check for items entering and exiting a zone, you can utilise zone methods: local playersArray = zone : getPlayers () Discover the full set of methods, events and properties at the Zone API .","title":"Summary"},{"location":"#optimisations","text":"Zones by default perform up to 10 checks per second in the centre of characters. This behaviour can be changed by modifying the Accuracy and Detection of zones:","title":"Optimisations"},{"location":"#accuracy","text":"This determines the frequency of checks per second. The accuracy of a zone can be changed two ways with a corresponding Accuracy Enum : Using the zone:setAccuracy(itemName) method: zone : setAccuracy ( \"High\" ) Setting the zone.accuracy property: zone . accuracy = Zone . enum . Accuracy . High By default accuracy is High . Info Modifying the accuracy of one zone may impact the accuracy of another due to the modules collaborative nature.","title":"Accuracy"},{"location":"#detection","text":"This determines the precision of checks. The way a zone detects players and parts can be changed two ways with a corresponding Detection Enum : Using the zone:setDetection(itemName) method: zone : setDetection ( \"WholeBody\" ) Setting the zone.enterDetection and zone.exitDetection properties: zone . enterDetection = Zone . enum . Detection . WholeBody zone . exitDetection = Zone . enum . Detection . WholeBody By default enterDetection and exitDetection are Centre . Info Modifying the detection of one zone may impact the detection of another due to the modules collaborative nature. Warning Setting enterDetection to ( Zone.enum.Detection.WholeBody or Zone.enum.Detection.Automatic ) and exitDetection to Zone.enum.Detection.Centre may cause the entered and exit events to trigger rapidly when the player lies on the bounds of the zone.","title":"Detection"},{"location":"changelog/","text":"[3.2.0] - September 7 2021 \u00b6 Added \u00b6 Zone:onItemEnter(characterOrBasePart, callbackFunction) Zone:onItemExit(characterOrBasePart, callbackFunction) An error warning when a zone is constructed using parts that don't belong to the Default collision group Support for non-basepart HeadParts Changed \u00b6 Reorganised checker parts Fixed \u00b6 A bug preventing the disconnection of tracked character parts which resulted in a slight memory leak whenever a player reset or changed bodyparts [3.1.0] - August 28 2021 \u00b6 Added \u00b6 Zone.fromRegion(cframe, size) zone:relocate() - Non-workspace zones are finally a possibility! Simply call this and the zones container will be moved into a WorldModel outside of Workspace. CollectiveWorldModel module zone.hasRelocated property zone.worldModel property zone.relocationContainer property CollectiveWorldModel.setupWorldModel(zone) CollectiveWorldModel:GetPartBoundsInBox(cframe, size, overlapParams) CollectiveWorldModel:GetPartBoundsInRadius(position, radius, overlapParams) `CollectiveWorldModel:GetPartsInPart(part, overlapParams) Changed \u00b6 Zone.new(zoneGroup) to Zone.new(container) zone.group property to zone.container Fixed \u00b6 \"ZoneController hrp is nil\" bug [3.0.0] - August 27 2021 \u00b6 Added \u00b6 Zone:trackItem(characterOrBasePart) Zone:untrackItem(characterOrBasePart) Zone.itemEntered event Zone.itemExited event Zone:findItem(characterOrBasePart) ZoneController.setGroup(settingsGroupName, properties) ZoneController.getGroup(settingsGroupName) SettingsGroup.onlyEnterOnceExitedAll property Zone:bindToGroup(settingsGroupName) Zone:unbindFromGroup(settingsGroupName) Zone.settingsGroupName property Zone:findPoint(position) ZoneController.getCharacterSize(character) Changed \u00b6 Internal behaviour to use the new Spatial Query API instead of the Region3 API. The default Detection from Automatic to Centre . The behaviour of Detection Centre to include the whole HumanoidRootPart instead of a singular Vector within (this was required due to the new Spatial Query API). Zone:findPart now returns array touchingZoneParts as its second value. Maid to Janitor by howmanysmall. Signal to GoodSignal by stravant. ZoneController.getTouchingZones(player) to ZoneController.getTouchingZones(characterOrBasePart) . Removed \u00b6 RotatedRegion3 ZoneController.getCharacterRegion ZoneController.verifyTouchingParts ZoneController.vectorIsBetweenYBounds ZoneController.getHeightOfParts Automatic Detection Enum. [2.2.3] - June 17 2021 \u00b6 Fixed \u00b6 The incorrect disabling of Seats and VehicleSeats within Part Zones. [2.2.2] - June 4 2021 \u00b6 Improved \u00b6 The accounting of character parts when removed/added via systems like HumanoidDescriptions. [2.2.1] - May 21 2021 \u00b6 Added \u00b6 Compatibility for Deferred Events [2.1.3] - May 7 2021 \u00b6 Fixed \u00b6 A bug that occured when disconnecting localPlayer events [2.1.2] - April 15 2021 \u00b6 Fixed \u00b6 playerExiting not firing when the player dies and respawns immidately within the zone. A rare nil checking bug within getTouchingZones in ZoneController . [2.1.1] - April 7 2021 \u00b6 Fixed \u00b6 nil comparison within ZoneController getTouchingZones line 450 [2.1.0] - March 5 2021 \u00b6 Added \u00b6 Detection Enum zone.enterDetection zone.exitDetection zone:setDetection(enumItemName) An Optimisation section to Introduction [2.0.0] - January 19 2021 \u00b6 Added \u00b6 Non-player part checking! (see methods below) Infinite zone volume, zero change in performance - zones can now be as large as you like with no additional impact to performance assuming characters/parts entering the zone remain their normal size or relatively small Zones now support MeshParts and UnionOperations (however it's recommended to use simple parts where possible as the former require additional raycast checks) Methods findLocalPlayer() findPlayer(player) findPart(basePart) getPlayers() getParts() setAccuracy(enumIdOrName) -- this enables you to customise the frequency of checks with enums 'Precise', 'High', 'Medium' and 'Low' 'Destroy' alias of 'destroy' Events localPlayerEntered localPlayerExited playerEntered playerExited partEntered partExited Changed \u00b6 A players whole body is now considered as apposed to just their central position Region checking significantly optimised (e.g. the zones region now rest on the voxel grid) Zones now act as a 'collective' which has significantly improved and optimised player and localplayer detection Removed all original aliases and events, including :initLoop() which no longer has to be called (connections are detected and handled internally automatically) Replaced frustrating require() dependencies with static modules Made Zone the parent module and others as descendants Removed the additonalHeight constructor argument - this caused confusion and added additional complexities to support :getRandomPoint() now returns randomVector, touchingGroupParts instead of randomCFrame, hitPart, hitIntersection zone.groupParts to zone.zoneParts Fixed \u00b6 Rotational and complex geometry detection getRandomPoints() inaccuracies -- This constructs a zone based upon a group of parts in Workspace and listens for when a player enters and exits this group local container = workspace.AModelOfPartsRepresentingTheZone local zone = Zone.new(container) zone.playerEntered:Connect(function(player) print((\"%s entered the zone!\"):format(player.Name)) end) zone.playerExited:Connect(function(player) print((\"%s exited the zone!\"):format(player.Name)) end) -- This constructs a zone based upon a region, tracks a Zombie NPC, then listens for when the item (aka the Zombie) enters and exits the zone. local zoneCFrame = CFrame.new() local zoneSize = Vector3.new(100, 100, 100) local zone = Zone.fromRegion(zoneCFrame, zoneSize) zone.itemEntered:Connect(function(item) print((\"%s entered the zone!\"):format(item.Name)) end) zone.itemExited:Connect(function(item) print((\"%s exited the zone!\"):format(item.Name)) end)","title":"Changelog"},{"location":"changelog/#320-september-7-2021","text":"","title":"[3.2.0] - September 7 2021"},{"location":"changelog/#added","text":"Zone:onItemEnter(characterOrBasePart, callbackFunction) Zone:onItemExit(characterOrBasePart, callbackFunction) An error warning when a zone is constructed using parts that don't belong to the Default collision group Support for non-basepart HeadParts","title":"Added"},{"location":"changelog/#changed","text":"Reorganised checker parts","title":"Changed"},{"location":"changelog/#fixed","text":"A bug preventing the disconnection of tracked character parts which resulted in a slight memory leak whenever a player reset or changed bodyparts","title":"Fixed"},{"location":"changelog/#310-august-28-2021","text":"","title":"[3.1.0] - August 28 2021"},{"location":"changelog/#added_1","text":"Zone.fromRegion(cframe, size) zone:relocate() - Non-workspace zones are finally a possibility! Simply call this and the zones container will be moved into a WorldModel outside of Workspace. CollectiveWorldModel module zone.hasRelocated property zone.worldModel property zone.relocationContainer property CollectiveWorldModel.setupWorldModel(zone) CollectiveWorldModel:GetPartBoundsInBox(cframe, size, overlapParams) CollectiveWorldModel:GetPartBoundsInRadius(position, radius, overlapParams) `CollectiveWorldModel:GetPartsInPart(part, overlapParams)","title":"Added"},{"location":"changelog/#changed_1","text":"Zone.new(zoneGroup) to Zone.new(container) zone.group property to zone.container","title":"Changed"},{"location":"changelog/#fixed_1","text":"\"ZoneController hrp is nil\" bug","title":"Fixed"},{"location":"changelog/#300-august-27-2021","text":"","title":"[3.0.0] - August 27 2021"},{"location":"changelog/#added_2","text":"Zone:trackItem(characterOrBasePart) Zone:untrackItem(characterOrBasePart) Zone.itemEntered event Zone.itemExited event Zone:findItem(characterOrBasePart) ZoneController.setGroup(settingsGroupName, properties) ZoneController.getGroup(settingsGroupName) SettingsGroup.onlyEnterOnceExitedAll property Zone:bindToGroup(settingsGroupName) Zone:unbindFromGroup(settingsGroupName) Zone.settingsGroupName property Zone:findPoint(position) ZoneController.getCharacterSize(character)","title":"Added"},{"location":"changelog/#changed_2","text":"Internal behaviour to use the new Spatial Query API instead of the Region3 API. The default Detection from Automatic to Centre . The behaviour of Detection Centre to include the whole HumanoidRootPart instead of a singular Vector within (this was required due to the new Spatial Query API). Zone:findPart now returns array touchingZoneParts as its second value. Maid to Janitor by howmanysmall. Signal to GoodSignal by stravant. ZoneController.getTouchingZones(player) to ZoneController.getTouchingZones(characterOrBasePart) .","title":"Changed"},{"location":"changelog/#removed","text":"RotatedRegion3 ZoneController.getCharacterRegion ZoneController.verifyTouchingParts ZoneController.vectorIsBetweenYBounds ZoneController.getHeightOfParts Automatic Detection Enum.","title":"Removed"},{"location":"changelog/#223-june-17-2021","text":"","title":"[2.2.3] - June 17 2021"},{"location":"changelog/#fixed_2","text":"The incorrect disabling of Seats and VehicleSeats within Part Zones.","title":"Fixed"},{"location":"changelog/#222-june-4-2021","text":"","title":"[2.2.2] - June 4 2021"},{"location":"changelog/#improved","text":"The accounting of character parts when removed/added via systems like HumanoidDescriptions.","title":"Improved"},{"location":"changelog/#221-may-21-2021","text":"","title":"[2.2.1] - May 21 2021"},{"location":"changelog/#added_3","text":"Compatibility for Deferred Events","title":"Added"},{"location":"changelog/#213-may-7-2021","text":"","title":"[2.1.3] - May 7 2021"},{"location":"changelog/#fixed_3","text":"A bug that occured when disconnecting localPlayer events","title":"Fixed"},{"location":"changelog/#212-april-15-2021","text":"","title":"[2.1.2] - April 15 2021"},{"location":"changelog/#fixed_4","text":"playerExiting not firing when the player dies and respawns immidately within the zone. A rare nil checking bug within getTouchingZones in ZoneController .","title":"Fixed"},{"location":"changelog/#211-april-7-2021","text":"","title":"[2.1.1] - April 7 2021"},{"location":"changelog/#fixed_5","text":"nil comparison within ZoneController getTouchingZones line 450","title":"Fixed"},{"location":"changelog/#210-march-5-2021","text":"","title":"[2.1.0] - March 5 2021"},{"location":"changelog/#added_4","text":"Detection Enum zone.enterDetection zone.exitDetection zone:setDetection(enumItemName) An Optimisation section to Introduction","title":"Added"},{"location":"changelog/#200-january-19-2021","text":"","title":"[2.0.0] - January 19 2021"},{"location":"changelog/#added_5","text":"Non-player part checking! (see methods below) Infinite zone volume, zero change in performance - zones can now be as large as you like with no additional impact to performance assuming characters/parts entering the zone remain their normal size or relatively small Zones now support MeshParts and UnionOperations (however it's recommended to use simple parts where possible as the former require additional raycast checks) Methods findLocalPlayer() findPlayer(player) findPart(basePart) getPlayers() getParts() setAccuracy(enumIdOrName) -- this enables you to customise the frequency of checks with enums 'Precise', 'High', 'Medium' and 'Low' 'Destroy' alias of 'destroy' Events localPlayerEntered localPlayerExited playerEntered playerExited partEntered partExited","title":"Added"},{"location":"changelog/#changed_3","text":"A players whole body is now considered as apposed to just their central position Region checking significantly optimised (e.g. the zones region now rest on the voxel grid) Zones now act as a 'collective' which has significantly improved and optimised player and localplayer detection Removed all original aliases and events, including :initLoop() which no longer has to be called (connections are detected and handled internally automatically) Replaced frustrating require() dependencies with static modules Made Zone the parent module and others as descendants Removed the additonalHeight constructor argument - this caused confusion and added additional complexities to support :getRandomPoint() now returns randomVector, touchingGroupParts instead of randomCFrame, hitPart, hitIntersection zone.groupParts to zone.zoneParts","title":"Changed"},{"location":"changelog/#fixed_6","text":"Rotational and complex geometry detection getRandomPoints() inaccuracies -- This constructs a zone based upon a group of parts in Workspace and listens for when a player enters and exits this group local container = workspace.AModelOfPartsRepresentingTheZone local zone = Zone.new(container) zone.playerEntered:Connect(function(player) print((\"%s entered the zone!\"):format(player.Name)) end) zone.playerExited:Connect(function(player) print((\"%s exited the zone!\"):format(player.Name)) end) -- This constructs a zone based upon a region, tracks a Zombie NPC, then listens for when the item (aka the Zombie) enters and exits the zone. local zoneCFrame = CFrame.new() local zoneSize = Vector3.new(100, 100, 100) local zone = Zone.fromRegion(zoneCFrame, zoneSize) zone.itemEntered:Connect(function(item) print((\"%s entered the zone!\"):format(item.Name)) end) zone.itemExited:Connect(function(item) print((\"%s exited the zone!\"):format(item.Name)) end)","title":"Fixed"},{"location":"contributing/","text":"Bug Reports \u00b6 To submit a bug report, open an issue with label Type: Bug or create a response at the discussion thread . Ensure your report includes a detailed explanation of the problem with any relavent images, videos, etc (such as console errors). Make sure to include a link to a stipped-down uncopylocked Roblox place which reproduces the bug. Questions and Feedback \u00b6 Be sure to check out the documentation and resources first before asking a question. We recommend submitting all questions and feedback to the discussion thread . You can also open an issue with label Type: Question . Submitting a resource (video tutorial, port, etc) \u00b6 Fancy making a tutorial or resource for ZonePlus? Feel free to get in touch and we can provide tips, best practices, etc. We'll feature approved resources on the resources page and often the discussion thread . To submit a resource, open an issue , or reach out on the discussion thread or to ForeverHD on the devforum . Suggestions and Code \u00b6 ZonePlus is completely free and open source; any suggestions and code contributions are greatly appreciated! To make a suggestion, open an issue with label Type: Enhancement or create a response at the discussion thread . Please open a suggestion before beginning a code contribution to ensure it's discussed through fully (we wouldn't want to waste your time!). Some tools you'll find useful when working on this project: Rojo Material for MKDocs Roblox LSP Documentation \u00b6 If you find any problems in the documentation, including typos, bad grammar, misleading phrasing, or missing content, feel free to file issues and pull requests to fix them. API documentation should be written at the top of the corresponding module under --[[ module:header . These comment blocks are automatically converted into markdown files and deployed to the site when pulled into the main branch. To test documentation: Install Material for MKDocs . Visit the ZonePlus repository . Click Fork in the top right corner. Clone this fork into your local repository. Change directory to this clone cd ZonePlus . Swap to the development branch git checkout development . Call mkdocs serve within your terminal. Open your local website (it will look something like http://0.0.0.0:8000 ) Any changes to mkdocs.yml or the files within docs will now update live to this local site. Important All pull requests must be made to the development branch.","title":"Contributing"},{"location":"contributing/#bug-reports","text":"To submit a bug report, open an issue with label Type: Bug or create a response at the discussion thread . Ensure your report includes a detailed explanation of the problem with any relavent images, videos, etc (such as console errors). Make sure to include a link to a stipped-down uncopylocked Roblox place which reproduces the bug.","title":"Bug Reports"},{"location":"contributing/#questions-and-feedback","text":"Be sure to check out the documentation and resources first before asking a question. We recommend submitting all questions and feedback to the discussion thread . You can also open an issue with label Type: Question .","title":"Questions and Feedback"},{"location":"contributing/#submitting-a-resource-video-tutorial-port-etc","text":"Fancy making a tutorial or resource for ZonePlus? Feel free to get in touch and we can provide tips, best practices, etc. We'll feature approved resources on the resources page and often the discussion thread . To submit a resource, open an issue , or reach out on the discussion thread or to ForeverHD on the devforum .","title":"Submitting a resource (video tutorial, port, etc)"},{"location":"contributing/#suggestions-and-code","text":"ZonePlus is completely free and open source; any suggestions and code contributions are greatly appreciated! To make a suggestion, open an issue with label Type: Enhancement or create a response at the discussion thread . Please open a suggestion before beginning a code contribution to ensure it's discussed through fully (we wouldn't want to waste your time!). Some tools you'll find useful when working on this project: Rojo Material for MKDocs Roblox LSP","title":"Suggestions and Code"},{"location":"contributing/#documentation","text":"If you find any problems in the documentation, including typos, bad grammar, misleading phrasing, or missing content, feel free to file issues and pull requests to fix them. API documentation should be written at the top of the corresponding module under --[[ module:header . These comment blocks are automatically converted into markdown files and deployed to the site when pulled into the main branch. To test documentation: Install Material for MKDocs . Visit the ZonePlus repository . Click Fork in the top right corner. Clone this fork into your local repository. Change directory to this clone cd ZonePlus . Swap to the development branch git checkout development . Call mkdocs serve within your terminal. Open your local website (it will look something like http://0.0.0.0:8000 ) Any changes to mkdocs.yml or the files within docs will now update live to this local site. Important All pull requests must be made to the development branch.","title":"Documentation"},{"location":"examples/","text":"Safe Zone \u00b6 Paint Zone \u00b6 Coin Spawner \u00b6 Voting Pads \u00b6 Random Part Generator \u00b6 Ambient Areas \u00b6 NPC Damager \u00b6 Sliding Doors \u00b6 All examples can be tested, viewed and edited at the Playground .","title":"Examples"},{"location":"examples/#safe-zone","text":"","title":"Safe Zone"},{"location":"examples/#paint-zone","text":"","title":"Paint Zone"},{"location":"examples/#coin-spawner","text":"","title":"Coin Spawner"},{"location":"examples/#voting-pads","text":"","title":"Voting Pads"},{"location":"examples/#random-part-generator","text":"","title":"Random Part Generator"},{"location":"examples/#ambient-areas","text":"","title":"Ambient Areas"},{"location":"examples/#npc-damager","text":"","title":"NPC Damager"},{"location":"examples/#sliding-doors","text":"All examples can be tested, viewed and edited at the Playground .","title":"Sliding Doors"},{"location":"installation/","text":"Method 1 - Take the model \u00b6 Take the ZonePlus model by Nanoblox. Open the toolbox and navigate to Inventory -> My Models. Click ZonePlus to insert into your game and place anywhere within ReplicatedStorage . Method 2 - Download from Releases \u00b6 Visit the latest release . Under Assets , download ZonePlus.rbxm . Within studio, navigate to MODEL -> Model and insert the file anywhere within ReplicatedStorage . Method 3 - With Rojo \u00b6 Setup with Rojo . Visit the ZonePlus repository . Click Fork in the top right corner. Clone this fork into your local repository. Modify the default.project.json file to your desired location (by default ZonePlus is built directly into ReplicatedStorage ). Call rojo serve (terminal or VSC plugin) and connect to the rojo studio plugin.","title":"Installation"},{"location":"installation/#method-1-take-the-model","text":"Take the ZonePlus model by Nanoblox. Open the toolbox and navigate to Inventory -> My Models. Click ZonePlus to insert into your game and place anywhere within ReplicatedStorage .","title":"Method 1 - Take the model"},{"location":"installation/#method-2-download-from-releases","text":"Visit the latest release . Under Assets , download ZonePlus.rbxm . Within studio, navigate to MODEL -> Model and insert the file anywhere within ReplicatedStorage .","title":"Method 2 - Download from Releases"},{"location":"installation/#method-3-with-rojo","text":"Setup with Rojo . Visit the ZonePlus repository . Click Fork in the top right corner. Clone this fork into your local repository. Modify the default.project.json file to your desired location (by default ZonePlus is built directly into ReplicatedStorage ). Call rojo serve (terminal or VSC plugin) and connect to the rojo studio plugin.","title":"Method 3 - With Rojo"},{"location":"method/","text":"Detection \u00b6 ZonePlus splits items into three categories: LocalPlayer Players Parts These categories then utilise unique methods to determine whether their corresponding item type is within a zone. Info It's important to understand that unlike in v1, zones now act as a collective through the ZoneController module. This means information can be generated once in a central area and shared with relavent zones, as apposed to each zone working independently. LocalPlayer \u00b6 While a localplayer-connection is active (i.e. when a developer connects to zone.localPlayerEntered/Exited )... Perform a WorldRoot:GetPartBoundsInBox check within the local player. An array of all zone group parts is used as its whitelist. Use this result to determine the zones the player is within. Update each of these returned zones and determine whether .localPlayerEntered or .localPlayerExited should be fired. If active, calculate the clock time of the next check based upon the zone.accuracy enum. Players \u00b6 While a player-connection is active (i.e. when a developer connects to zone.playerEntered/Exited )... Compare the total volume of all zones against the total volume of all player characters (these are pre-determined through events instead of calculating every check). If the total characters volume is less than the total zone volume then: Iterate through each player in the server. Perform a WorldRoot:GetPartBoundsInBox check over the local player. A collective of all zone group parts is used as its whitelist. Find the corresponding zone of these bound parts. If that zone is entirely made up of Blocks, then register instantly. If not, then perform a WorldRoot:GetPartsInPart check (which is more precise) using the previous result as its whitelist. Register these successful results. If a returned zone has an active player connection, update it and determine if .playerEntered(player) or .playerExited(player) should be called. Else if the total characters volume is greater than the total zone volume then: Iterate through each active zone. If the zone has an active player connection, perform a WorldRoot:GetPartBoundsInBox check of the zones rough area using all character parts within the server as a whitelist. Using a dictionary, match the bodyparts to their corresponding players. For each player detected, perform the same precise checks over their character highlighted in (3). Update the zone with these players and fire .playerEntered(player) and/or .playerExited(player) where necessary. If active, calculate the clock time of the next check based upon the zone.accuracy enum. Parts \u00b6 When a part-connection is formed (i.e. when a developer connects to zone.partEntered/Exited ), apply a touched event to all group-parts within the zone. When a part touches one of these group-parts, set its .CanTouch property to false . Fire .partEntered(part) and form a 'tracking connection' for the part. While this tracking connection is active... Perform a 'tiny check' (of size (0.1, 0.1, 0.1) , using the zones group parts as a whitelist) to verify the parts center is still within the zone. If this returns false, then it means the part is either on the outer bounds of the zone or has exited. Now perform a whole-body WorldRoot:GetPartBoundsInBox (or WorldRoot:GetPartsInPart if more precision if required if the zone contains non-block baseparts) check, with the zones group parts as a whitelist. If this returns false, then the part has exited the zone. Fire .partExited(part) , disconnect the tracking connection and set the parts .CanTouch property back to true . Else if the tracking connection is still active, calculate the clock time of the next check based upon the zone.accuracy enum. If all part-connections are disconnected, disconnect all touched events and end any tracking connections. Items \u00b6 Same methodology as Players , except using tracked instances from zone:trackItem(item) instead of a players character. Optimisations \u00b6 Whitelists everywhere . ZonePlus ensures only necessary parts (such as a characters HumanoidRootPart) are tracked and then passed through to whitelists when performing checks. A zones Region coordinates are rounded up to the nearest multiple of 4 to ensure it rests on the voxel grid. The volume comparisons enable zones to determine players inside with optimal efficiency. For instance, if a server contains a single 8x8x8 zone and 100 players of size 4x5x1 , its significantly more efficient to check only the zone (of volume 512 ), as apposed to every player (of total volume 2000 ). Likewise, if you have multiple large zones which cover a map and few players in a server, it's going to be significantly more optimal to check each player as apposed to every zone. For the experimental part events, .Touched abuse checks are enforced to prevent parts firing these events more than the property value of whatever enum.accuracy is.","title":"Method"},{"location":"method/#detection","text":"ZonePlus splits items into three categories: LocalPlayer Players Parts These categories then utilise unique methods to determine whether their corresponding item type is within a zone. Info It's important to understand that unlike in v1, zones now act as a collective through the ZoneController module. This means information can be generated once in a central area and shared with relavent zones, as apposed to each zone working independently.","title":"Detection"},{"location":"method/#localplayer","text":"While a localplayer-connection is active (i.e. when a developer connects to zone.localPlayerEntered/Exited )... Perform a WorldRoot:GetPartBoundsInBox check within the local player. An array of all zone group parts is used as its whitelist. Use this result to determine the zones the player is within. Update each of these returned zones and determine whether .localPlayerEntered or .localPlayerExited should be fired. If active, calculate the clock time of the next check based upon the zone.accuracy enum.","title":"LocalPlayer"},{"location":"method/#players","text":"While a player-connection is active (i.e. when a developer connects to zone.playerEntered/Exited )... Compare the total volume of all zones against the total volume of all player characters (these are pre-determined through events instead of calculating every check). If the total characters volume is less than the total zone volume then: Iterate through each player in the server. Perform a WorldRoot:GetPartBoundsInBox check over the local player. A collective of all zone group parts is used as its whitelist. Find the corresponding zone of these bound parts. If that zone is entirely made up of Blocks, then register instantly. If not, then perform a WorldRoot:GetPartsInPart check (which is more precise) using the previous result as its whitelist. Register these successful results. If a returned zone has an active player connection, update it and determine if .playerEntered(player) or .playerExited(player) should be called. Else if the total characters volume is greater than the total zone volume then: Iterate through each active zone. If the zone has an active player connection, perform a WorldRoot:GetPartBoundsInBox check of the zones rough area using all character parts within the server as a whitelist. Using a dictionary, match the bodyparts to their corresponding players. For each player detected, perform the same precise checks over their character highlighted in (3). Update the zone with these players and fire .playerEntered(player) and/or .playerExited(player) where necessary. If active, calculate the clock time of the next check based upon the zone.accuracy enum.","title":"Players"},{"location":"method/#parts","text":"When a part-connection is formed (i.e. when a developer connects to zone.partEntered/Exited ), apply a touched event to all group-parts within the zone. When a part touches one of these group-parts, set its .CanTouch property to false . Fire .partEntered(part) and form a 'tracking connection' for the part. While this tracking connection is active... Perform a 'tiny check' (of size (0.1, 0.1, 0.1) , using the zones group parts as a whitelist) to verify the parts center is still within the zone. If this returns false, then it means the part is either on the outer bounds of the zone or has exited. Now perform a whole-body WorldRoot:GetPartBoundsInBox (or WorldRoot:GetPartsInPart if more precision if required if the zone contains non-block baseparts) check, with the zones group parts as a whitelist. If this returns false, then the part has exited the zone. Fire .partExited(part) , disconnect the tracking connection and set the parts .CanTouch property back to true . Else if the tracking connection is still active, calculate the clock time of the next check based upon the zone.accuracy enum. If all part-connections are disconnected, disconnect all touched events and end any tracking connections.","title":"Parts"},{"location":"method/#items","text":"Same methodology as Players , except using tracked instances from zone:trackItem(item) instead of a players character.","title":"Items"},{"location":"method/#optimisations","text":"Whitelists everywhere . ZonePlus ensures only necessary parts (such as a characters HumanoidRootPart) are tracked and then passed through to whitelists when performing checks. A zones Region coordinates are rounded up to the nearest multiple of 4 to ensure it rests on the voxel grid. The volume comparisons enable zones to determine players inside with optimal efficiency. For instance, if a server contains a single 8x8x8 zone and 100 players of size 4x5x1 , its significantly more efficient to check only the zone (of volume 512 ), as apposed to every player (of total volume 2000 ). Likewise, if you have multiple large zones which cover a map and few players in a server, it's going to be significantly more optimal to check each player as apposed to every zone. For the experimental part events, .Touched abuse checks are enforced to prevent parts firing these events more than the property value of whatever enum.accuracy is.","title":"Optimisations"},{"location":"resources/","text":"Model Playground Discussion Repository If you would like to submit a resource (such as a video tutorial, port, etc), please see contributing .","title":"Resources"},{"location":"api/zone/","text":"Construtors \u00b6 new \u00b6 local zone = Zone . new ( container ) A container is used the define the boundaries of the zone. It can be any non-basepart instance (such as a Model, Folder, etc) that contain descendant baseparts. Alternatively a container can be a singular basepart instance, or a table containing an array of baseparts. fromRegion \u00b6 local zone = Zone . fromRegion ( cframe , size ) Constructs a zone from the given CFrame and Size. Underneath the hood, it's creating a part (or multiple parts if any size coordinage exceeds 2024), parenting this to a folder (the container), constructing a zone with this container, calling :relocate() on that zone (which parents it outside of workspace), then finally returning the zone. Methods \u00b6 findLocalPlayer \u00b6 local isWithinZoneBool = zone : findLocalPlayer () findPlayer \u00b6 local isWithinZoneBool = zone : findPlayer ( player ) findPart \u00b6 local isWithinZoneBool , touchingZoneParts = zone : findPart ( basePart ) findItem \u00b6 local isWithinZoneBool , touchingZoneParts = zone : findItem ( basePartOrCharacter ) findPoint \u00b6 local isWithinZoneBool , touchingZoneParts = zone : findPoint ( position ) getPlayers \u00b6 local playersArray = zone : getPlayers () getParts \u00b6 local partsArray = zone : getParts () getItems \u00b6 local itemsArray = zone : getItems () getRandomPoint \u00b6 local randomVector , touchingZonePartsArray = zone : getRandomPoint () Generates random points within the zones region until one falls within its bounds. It then returns this Vector3 and a table array of group parts the point falls within. trackItem \u00b6 zone : trackItem ( characterOrBasePart ) This is used to detect your own custom instances within zones, such as NPCs, and is a recommended replacement for part-events/methods. An item can be any BasePart or Character/NPC (i.e. a model with a Humanoid and HumanoidRootPart). Once tracked, it can be listened for with the zone.itemEntered and zone.itemExited events. An item will be automatically untracked if destroyed or has its parent set to nil . untrackItem \u00b6 zone : untrackItem ( characterOrBasePart ) bindToGroup \u00b6 zone : bindToGroup ( settingsGroupName ) This is used to bind the zone to a settingsGroup to enhance the default behaviour of a collection of zones. The properties of a settingsGroup can be viewed at and customised using ZoneController.setGroup . This method is particularly useful for zones where you want to guarantee the player/item is not in two zones at once. For example, when working with ambient/music/lighting zones which perfectly border each other. unbindFromGroup \u00b6 zone : bindToGroup ( settingsGroupName ) setDetection \u00b6 zone : setDetection ( enumIdOrName ) Sets the precision of checks based upon the Detection Enum . Defaults to 'Automatic'. relocate \u00b6 zone : relocate () Moves the zone outside of workspace into a separate WorldModel within ReplicatedStorage or ServerStorage. This action is irreversible - once called it cannot be undone. onItemEnter \u00b6 zone : onItemEnter ( characterOrBasePart , callbackFunction ) Tracks the item until it has entered the zone, then calls the given function. If the item is already within the zone, the given function is called right away. local item = character : FindFirstChild ( \"HumanoidRootPart\" ) zone : onItemEnter ( item , function () print ( \"The item has entered the zone!\" )) end ) onItemExit \u00b6 zone : onItemExit ( characterOrBasePart , callbackFunction ) Tracks the item until it has exited the zone, then calls the given function. If the item is already outside the zone, the given function is called right away. local item = character : FindFirstChild ( \"HumanoidRootPart\" ) zone : onItemExit ( item , function () print ( \"The item has exited the zone!\" )) end ) destroy \u00b6 zone : destroy () Disconnects all connections within the zone. Events \u00b6 localPlayerEntered \u00b6 {client-only} zone . localPlayerEntered : Connect ( function () print ( \"you entered the zone!\" ) end ) localPlayerExited \u00b6 {client-only} zone . localPlayerExited : Connect ( function () print ( \"you exited the zone!\" ) end ) playerEntered \u00b6 zone . playerEntered : Connect ( function ( player ) print (( \"player '%s' entered the zone!\" ): format ( player . Name )) end ) playerExited \u00b6 zone . playerExited : Connect ( function ( player ) print (( \"player '%s' exited the zone!\" ): format ( player . Name )) end ) partEntered \u00b6 zone . partEntered : Connect ( function ( part ) print (( \"part '%s' entered the zone!\" ): format ( part . Name )) end ) Info This event works only for unanchored parts and may interfere with the parts CanCollide property. It's recommended to use itemEntered instead where possible which is more optimal and overcomes these problems. partExited \u00b6 zone . partExited : Connect ( function ( part ) print (( \"part '%s' exited the zone!\" ): format ( part . Name )) end ) Info This event works only for unanchored parts and may interfere with the parts CanCollide property. It's recommended to use itemExited instead where possible which is more optimal and overcomes these problems. itemEntered \u00b6 zone . itemEntered : Connect ( function ( item ) print (( \"item '%s' entered the zone!\" ): format ( item . Name )) end ) See icon:trackItem for further details on items. itemExited \u00b6 zone . itemExited : Connect ( function ( item ) print (( \"item '%s' exited the zone!\" ): format ( item . Name )) end ) See icon:trackItem for further details on items. Properties \u00b6 accuracy \u00b6 local accuracyEnumId = zone . accuracy --[default: 'Zone.enum.Accuracy.High'] To change accuracy you can use setAccuracy or do: zone . accuracy = Zone . enum . Accuracy . ITEM_NAME A list of Accuracy enum items can be found at Accuracy Enum . enterDetection \u00b6 local enterDetection = zone . enterDetection --[default: 'Zone.enum.Detection.Automatic'] To change both detection types use setDetection otherwise to set individually do: zone . enterDetection = Zone . enum . Detection . ITEM_NAME A list of Detection enum items can be found at Detection Enum . exitDetection \u00b6 local exitDetection = zone . exitDetection --[default: 'Zone.enum.Detection.Automatic'] To change both detection types use setDetection otherwise to set individually do: zone . exitDetection = Zone . enum . Detection . ITEM_NAME A list of Detection enum items can be found at Detection Enum . autoUpdate \u00b6 local bool = zone . autoUpdate --[default: 'true'] When true , the zone will update when its group parts change size or position, or when a descendant group part is added or removed from the group. respectUpdateQueue \u00b6 local bool = zone . respectUpdateQueue --[default: 'true'] When true , will prevent the internal _update() from being called multiple times within a 0.1 second period. zoneParts \u00b6 {read-only} An array of baseparts, defined in the container constructor parameter, that form the zone. region \u00b6 {read-only} volume \u00b6 {read-only} worldModel \u00b6 {read-only}","title":"Zone"},{"location":"api/zone/#construtors","text":"","title":"Construtors"},{"location":"api/zone/#new","text":"local zone = Zone . new ( container ) A container is used the define the boundaries of the zone. It can be any non-basepart instance (such as a Model, Folder, etc) that contain descendant baseparts. Alternatively a container can be a singular basepart instance, or a table containing an array of baseparts.","title":"new"},{"location":"api/zone/#fromregion","text":"local zone = Zone . fromRegion ( cframe , size ) Constructs a zone from the given CFrame and Size. Underneath the hood, it's creating a part (or multiple parts if any size coordinage exceeds 2024), parenting this to a folder (the container), constructing a zone with this container, calling :relocate() on that zone (which parents it outside of workspace), then finally returning the zone.","title":"fromRegion"},{"location":"api/zone/#methods","text":"","title":"Methods"},{"location":"api/zone/#findlocalplayer","text":"local isWithinZoneBool = zone : findLocalPlayer ()","title":"findLocalPlayer"},{"location":"api/zone/#findplayer","text":"local isWithinZoneBool = zone : findPlayer ( player )","title":"findPlayer"},{"location":"api/zone/#findpart","text":"local isWithinZoneBool , touchingZoneParts = zone : findPart ( basePart )","title":"findPart"},{"location":"api/zone/#finditem","text":"local isWithinZoneBool , touchingZoneParts = zone : findItem ( basePartOrCharacter )","title":"findItem"},{"location":"api/zone/#findpoint","text":"local isWithinZoneBool , touchingZoneParts = zone : findPoint ( position )","title":"findPoint"},{"location":"api/zone/#getplayers","text":"local playersArray = zone : getPlayers ()","title":"getPlayers"},{"location":"api/zone/#getparts","text":"local partsArray = zone : getParts ()","title":"getParts"},{"location":"api/zone/#getitems","text":"local itemsArray = zone : getItems ()","title":"getItems"},{"location":"api/zone/#getrandompoint","text":"local randomVector , touchingZonePartsArray = zone : getRandomPoint () Generates random points within the zones region until one falls within its bounds. It then returns this Vector3 and a table array of group parts the point falls within.","title":"getRandomPoint"},{"location":"api/zone/#trackitem","text":"zone : trackItem ( characterOrBasePart ) This is used to detect your own custom instances within zones, such as NPCs, and is a recommended replacement for part-events/methods. An item can be any BasePart or Character/NPC (i.e. a model with a Humanoid and HumanoidRootPart). Once tracked, it can be listened for with the zone.itemEntered and zone.itemExited events. An item will be automatically untracked if destroyed or has its parent set to nil .","title":"trackItem"},{"location":"api/zone/#untrackitem","text":"zone : untrackItem ( characterOrBasePart )","title":"untrackItem"},{"location":"api/zone/#bindtogroup","text":"zone : bindToGroup ( settingsGroupName ) This is used to bind the zone to a settingsGroup to enhance the default behaviour of a collection of zones. The properties of a settingsGroup can be viewed at and customised using ZoneController.setGroup . This method is particularly useful for zones where you want to guarantee the player/item is not in two zones at once. For example, when working with ambient/music/lighting zones which perfectly border each other.","title":"bindToGroup"},{"location":"api/zone/#unbindfromgroup","text":"zone : bindToGroup ( settingsGroupName )","title":"unbindFromGroup"},{"location":"api/zone/#setdetection","text":"zone : setDetection ( enumIdOrName ) Sets the precision of checks based upon the Detection Enum . Defaults to 'Automatic'.","title":"setDetection"},{"location":"api/zone/#relocate","text":"zone : relocate () Moves the zone outside of workspace into a separate WorldModel within ReplicatedStorage or ServerStorage. This action is irreversible - once called it cannot be undone.","title":"relocate"},{"location":"api/zone/#onitementer","text":"zone : onItemEnter ( characterOrBasePart , callbackFunction ) Tracks the item until it has entered the zone, then calls the given function. If the item is already within the zone, the given function is called right away. local item = character : FindFirstChild ( \"HumanoidRootPart\" ) zone : onItemEnter ( item , function () print ( \"The item has entered the zone!\" )) end )","title":"onItemEnter"},{"location":"api/zone/#onitemexit","text":"zone : onItemExit ( characterOrBasePart , callbackFunction ) Tracks the item until it has exited the zone, then calls the given function. If the item is already outside the zone, the given function is called right away. local item = character : FindFirstChild ( \"HumanoidRootPart\" ) zone : onItemExit ( item , function () print ( \"The item has exited the zone!\" )) end )","title":"onItemExit"},{"location":"api/zone/#destroy","text":"zone : destroy () Disconnects all connections within the zone.","title":"destroy"},{"location":"api/zone/#events","text":"","title":"Events"},{"location":"api/zone/#localplayerentered","text":"{client-only} zone . localPlayerEntered : Connect ( function () print ( \"you entered the zone!\" ) end )","title":"localPlayerEntered"},{"location":"api/zone/#localplayerexited","text":"{client-only} zone . localPlayerExited : Connect ( function () print ( \"you exited the zone!\" ) end )","title":"localPlayerExited"},{"location":"api/zone/#playerentered","text":"zone . playerEntered : Connect ( function ( player ) print (( \"player '%s' entered the zone!\" ): format ( player . Name )) end )","title":"playerEntered"},{"location":"api/zone/#playerexited","text":"zone . playerExited : Connect ( function ( player ) print (( \"player '%s' exited the zone!\" ): format ( player . Name )) end )","title":"playerExited"},{"location":"api/zone/#partentered","text":"zone . partEntered : Connect ( function ( part ) print (( \"part '%s' entered the zone!\" ): format ( part . Name )) end ) Info This event works only for unanchored parts and may interfere with the parts CanCollide property. It's recommended to use itemEntered instead where possible which is more optimal and overcomes these problems.","title":"partEntered"},{"location":"api/zone/#partexited","text":"zone . partExited : Connect ( function ( part ) print (( \"part '%s' exited the zone!\" ): format ( part . Name )) end ) Info This event works only for unanchored parts and may interfere with the parts CanCollide property. It's recommended to use itemExited instead where possible which is more optimal and overcomes these problems.","title":"partExited"},{"location":"api/zone/#itementered","text":"zone . itemEntered : Connect ( function ( item ) print (( \"item '%s' entered the zone!\" ): format ( item . Name )) end ) See icon:trackItem for further details on items.","title":"itemEntered"},{"location":"api/zone/#itemexited","text":"zone . itemExited : Connect ( function ( item ) print (( \"item '%s' exited the zone!\" ): format ( item . Name )) end ) See icon:trackItem for further details on items.","title":"itemExited"},{"location":"api/zone/#properties","text":"","title":"Properties"},{"location":"api/zone/#accuracy","text":"local accuracyEnumId = zone . accuracy --[default: 'Zone.enum.Accuracy.High'] To change accuracy you can use setAccuracy or do: zone . accuracy = Zone . enum . Accuracy . ITEM_NAME A list of Accuracy enum items can be found at Accuracy Enum .","title":"accuracy"},{"location":"api/zone/#enterdetection","text":"local enterDetection = zone . enterDetection --[default: 'Zone.enum.Detection.Automatic'] To change both detection types use setDetection otherwise to set individually do: zone . enterDetection = Zone . enum . Detection . ITEM_NAME A list of Detection enum items can be found at Detection Enum .","title":"enterDetection"},{"location":"api/zone/#exitdetection","text":"local exitDetection = zone . exitDetection --[default: 'Zone.enum.Detection.Automatic'] To change both detection types use setDetection otherwise to set individually do: zone . exitDetection = Zone . enum . Detection . ITEM_NAME A list of Detection enum items can be found at Detection Enum .","title":"exitDetection"},{"location":"api/zone/#autoupdate","text":"local bool = zone . autoUpdate --[default: 'true'] When true , the zone will update when its group parts change size or position, or when a descendant group part is added or removed from the group.","title":"autoUpdate"},{"location":"api/zone/#respectupdatequeue","text":"local bool = zone . respectUpdateQueue --[default: 'true'] When true , will prevent the internal _update() from being called multiple times within a 0.1 second period.","title":"respectUpdateQueue"},{"location":"api/zone/#zoneparts","text":"{read-only} An array of baseparts, defined in the container constructor parameter, that form the zone.","title":"zoneParts"},{"location":"api/zone/#region","text":"{read-only}","title":"region"},{"location":"api/zone/#volume","text":"{read-only}","title":"volume"},{"location":"api/zone/#worldmodel","text":"{read-only}","title":"worldModel"},{"location":"api/zone_controller/","text":"Functions \u00b6 getZones \u00b6 local zonesArray = ZoneController . getZones () getTouchingZones \u00b6 local touchingZonesArray , touchingPartsDictionary = ZoneController . getTouchingZones ( player ) setGroup \u00b6 local settingsGroup = ZoneController . setGroup ( settingsGroupName , properties ) properties is a dictionary defining the groups settings. The default properties are: { onlyEnterOnceExitedAll = true , -- When set to `true`, it prevents items (players, parts, etc) from entering multiple zones at once within that group. } A zone can be bound to a group using zone:bindToGroup . getGroup \u00b6 local settingsGroup = ZoneController . getGroup ( settingsGroupName )","title":"ZoneController"},{"location":"api/zone_controller/#functions","text":"","title":"Functions"},{"location":"api/zone_controller/#getzones","text":"local zonesArray = ZoneController . getZones ()","title":"getZones"},{"location":"api/zone_controller/#gettouchingzones","text":"local touchingZonesArray , touchingPartsDictionary = ZoneController . getTouchingZones ( player )","title":"getTouchingZones"},{"location":"api/zone_controller/#setgroup","text":"local settingsGroup = ZoneController . setGroup ( settingsGroupName , properties ) properties is a dictionary defining the groups settings. The default properties are: { onlyEnterOnceExitedAll = true , -- When set to `true`, it prevents items (players, parts, etc) from entering multiple zones at once within that group. } A zone can be bound to a group using zone:bindToGroup .","title":"setGroup"},{"location":"api/zone_controller/#getgroup","text":"local settingsGroup = ZoneController . getGroup ( settingsGroupName )","title":"getGroup"}]}